from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime
from uuid import UUID

# âœ… Base schema shared by all others
class FaceBase(BaseModel):
    face_id: UUID  # UUID of the face
    photo_id: UUID  # Foreign key to the `photos` table
    partner: Optional[str] = None  # Partner associated with the face
    bbox: Optional[Dict[str, Any]] = {}  # Bounding box as a JSONB (a dictionary)
    embedding: Optional[List[float]] = None  # Embedding as an array of floats
    det_score: Optional[float] = None  # Detection score
    pose: Optional[Dict[str, Any]] = {}  # Pose as a JSONB (a dictionary)
    landmarks: Optional[Dict[str, Any]] = {}  # Pose as a JSONB (a dictionary)
    member_id: Optional[str] = None  # Member ID associated with the face
    roster_id: Optional[str] = None  # Roster ID associated with the face
    data: Optional[Dict[str, Any]] = {}  # Metadata as a JSONB (a dictionary)

    created_at: Optional[datetime] = None  # Timestamp when the face record was created
    updated_at: Optional[datetime] = None  # Timestamp when the face record was last updated

# ðŸŸ¢ POST /faces â€” Create
class FaceCreate(FaceBase):
    id: Optional[int]  # Optional because it will be auto-generated by SQLAlchemy

# ðŸŸ¡ PATCH /faces/{id} â€” Update
class FaceUpdate(BaseModel):
    partner: Optional[str] = None
    bbox: Optional[Dict[str, Any]] = None
    embedding: Optional[List[float]] = None
    det_score: Optional[float] = None
    pose: Optional[Dict[str, Any]] = None
    landmarks: Optional[List[float]] = None
    member_id: Optional[str] = None
    roster_id: Optional[str] = None
    data: Optional[Dict[str, Any]] = None
    # Add only the fields that are allowed to be updated

# ðŸ”µ GET /faces/{id} â€” Read (or list)
class FaceSchema(FaceCreate):
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True  # To read data from SQLAlchemy model instances
